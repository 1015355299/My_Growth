# 树

LeetCode试题

## 难度:简单

#100 相同树

思路：使用递归，递归只判断当前节点情况，判断节点值为空情况，接着判断是否不等，如果相等则进行进一步左右子节点对比

#101 对称二叉树

思路：从根节点开始判断2个节点为空情况，以及不等情况，如果相等继续判断下一个左右子树的对称节点情况，思路与#100类似，差别在于，传入递归的子节点是对称位置的节点

#104 二叉树的最大深度

思路：如果当前节点为空则返回当前计数num，否则num++，再对左右节点进行计算最大深度，如果左子深度大于右子深度，则返回左子深度，依此类推，只要是有效层则num将会+1

#107 二叉树的层次遍历II

思路：层次遍历，使用队列把当前节点入队列，之后出队，再把左右子树入队，最后反转数组

#108 将有序数组转换为二叉搜索树

思路；每次递归从数组中间开始创建节点，再递归生成左右节点，最后返回此节点作为上层递归节点的子节点，出口为当前数组无法再被分割

#110 平衡二叉树

思路：通过对每个节点判断子树高度差，递归节点直到null返回高度0，如果一个节点不满足则返回false，如果满足则返回当前节点最高高度，供上层递归比对高度差，直到根节点

#111 二叉树的最小深度

思路：对每个节点进行最小深度计算，如果当前计算的节点为null则返回递归出传入的深度，如果当前左右子节点都为null则说明是子叶节点，那么将深度+1之后再返回深度，如过最多一个子树为null则返回另一边的深度，如果都不为null则返回最小的那一边深度

#112 路径总和

思路：没递归一层sum减去当前节点值，再传入下一节点，如果当前为子叶节点并且sum为0则返回true，若sum不为0则此条路径无效返回false，这里要对根节点单独判断，如果根节点为null则返回false，递归思路同#111

#226 翻转二叉树

思路：除了递归出口的判断，也就是判断子叶和根为空的情况。还需要对左右子树分别递归，直到出口，最后再进行交换，也就是递归位置在交换之前，这样是自底向上翻转

#235 二叉搜索树的最近公共祖先

思路：根据搜索树特性，对q、p与当前节点值比对，如果都比当前节点小那么继续左子树递归，如果都大继续右子树递归，否则返回当前节点，即最近的公共祖先

#257 二叉树的所有路径

思路：返回二叉树的所有到叶子节点的路径，那么递归到叶子节点时就可以把一路拼接的字符串push到保存的数组中，最后再返回，当不是叶子节点时，继续拼接路径，根据子树情况进行递归选择

#404 左叶子之和

思路：在非子叶节点判断其左子叶节点是否存在，如果存在则返回左子叶节点的值和其又节点递归值的和，如果当前节点为null则返回0

#501 二叉搜索树中的众数

思路：使用中序遍历，为有序数组，记录当前和上一个值，使用者2个值对一个数字进行计数，并且更新最大计数值如果当前最大计数值与之前记录的最大计数值相同，则数组添加新众数，否则覆盖原来众数列表，注意变量作用域

