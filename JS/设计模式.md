
# js之设计模式

## 单例模式

- 单例模式的定义是：保证一个类仅有一个实例，并提供一个访问它的全局访问点。
- 单例模式的核心是确保只有一个实例，并提供全局访问。

静态方法获取单例

```通过静态方法获取单例
// 创建单例
const Singleton = function (name) {
  this.name = name
  this.instance = null
}
Singleton.prototype.getName = function () {
  return this.name
}
// 获取单例
Singleton.getInstance = function (name) {
  // 判断单例是否存在
  if (!this.instance) {
    this.instance = new Singleton(name)
  }
  return this.instance
}
console.log(Singleton.getInstance() === Singleton.getInstance()) // true
```

通过闭包创建单例模式

```闭包单例
//单例构造函数
const Singleton = function (name) {
  this.name = name
}
Singleton.prototype.getName = function () {
  return this.name
}
Singleton.getInstance = (function () {
  let instance = null
  return function (name) {
    if (!instance) {
      instance = new Singleton(name)
    }
    return instance
  }
})()
console.log(Singleton.getInstance('h') === Singleton.getInstance('hh'))
```

基于代理的单例模式

```代理单例
// 基于代理的单例模式
// 单例构造函数-只构造单例
function Singleton(element, html) {
  this.element = element
  this.html = html
  this.init()
}
Singleton.prototype.init = function () {
  const ele = document.createElement(this.element)
  ele.innerHTML = this.html
  document.body.appendChild(ele)
}
const proxySingletonCreateElement = (function () {
  let instance = null
  return function (element, html) {
    if (!instance) {
      instance = new Singleton(element, html)
    }
    return instance
  }
})()
const ele1 = new proxySingletonCreateElement('div', '5')
const ele2 = new proxySingletonCreateElement()
console.log(ele1 === ele2) //true
```

// js终极单例模式

```单例模式
// js之单例模式
// 创建元素构造函数
const CreateElement = function (ele, fn) {
  const element = document.createElement(ele)
  element.name = ele // 用于识别单例标签
  element.style.display = 'none' // 默认隐藏
  fn(element)
  document.body.appendChild(element)
  return element
}
// 获取单例函数
const SingletonElement = function (create) {
  const instance = {} // 闭包保存每个标签单例
  return {
    createSingletonElement(ele = 'div', fn = function () {}) {
      // 如果同标签且创建过直接返回
      if (instance[ele] && instance[ele].name === ele)
        return instance[ele]
      // 不同标签或者没创建过，新建一个
      return (instance[ele] = new create(ele, fn))
    },
    getInstances() {
      return instance
    },
  }
}
// 创建构造单例模式函数
const SingletonCreate = SingletonElement(CreateElement)

/*
const div = SingletonCreate.createSingletonElement('div')
const div1 = SingletonCreate.createSingletonElement('div')
const span = SingletonCreate.createSingletonElement('span')
const span1 = SingletonCreate.createSingletonElement('span')
console.log(div === div1, span === span1, div === span) // true,true,false
console.log(SingletonCreate.getInstances())  
*/
document.querySelector('button').addEventListener('click', () => {
  const div = SingletonCreate.createSingletonElement('div', (e) => {
    console.log(e)
    e.innerHTML = '哈哈'
  })
  div.style.display = 'block'
})
```

个人理解

- 单例模式就是一个供全局访问的一个对象，且这个对象只有一个
- 通过实例化出来的这个对象要满足全局唯一且可以全局访问
- 比如整个项目只需要一个实例，弹窗不需要重复创建通过设置显示隐藏，缓存区不需要多个一个就是包含全部的缓存数据

## 策略模式

- 策略模式的定义是：定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换。

基于原型的策略模式，不变的算法实现与变化的输入数据分开

```基于原型的策略模式
//策略模式
// 定义不同等级算法
const Level1 = function () {}
Level1.prototype.compute = function (salary) {
  return salary * 2
}

const Level2 = function () {}
Level2.prototype.compute = function (salary) {
  return salary * 3
}

const Level3 = function () {}
Level3.prototype.compute = function (salary) {
  return salary * 4
}

const Level4 = function () {}
Level4.prototype.compute = function (salary) {
  return salary * 5
}

// 定义员工
const Staff = function () {
  this.salary = null
  this.level = null
}
// 设置每个员工的基础薪资
Staff.prototype.setSalary = function (salary) {
  this.salary = salary
}
// 设置每个员工的等级
Staff.prototype.setLevel = function (level) {
  this.level = level
}
// 获取员工的总工资
Staff.prototype.getTotalSalary = function () {
  return this.level.compute(this.salary)
}
const s1 = new Staff()
s1.setSalary(5000)
s1.setLevel(new Level1()) // 2
console.log(s1.getTotalSalary()) // 10000=5000*2

const s2 = new Staff()
s2.setSalary(6000)
s2.setLevel(new Level4()) // 5
console.log(s2.getTotalSalary()) // 30000=6000*5
```

js策略模式，输入的不同等级执行对应的算法，每个算法单独封装在一个集合里，通过输入执行对应算法

```策略模式
// 等级对应的薪资算法
const compute = {
  1(salary) {
    return salary * 2
  },
  2(salary) {
    return salary * 3
  },
  3(salary) {
    return salary * 4
  },
  4(salary) {
    return salary * 5
  },
}
// 计算总薪资
const totalSalary = function (salary, level) {
  return compute[level](salary)
}
console.log(totalSalary(5000, 1)) // 10000
console.log(totalSalary(6000, 4)) // 30000
```

基于js策略模式的表单验证

```表单验证
<form action="" method="POST" id="registerForm">
  <input type="text" name="username" />
  <input type="text" name="password" />
  <input type="text" name="phone" />
  <button type="submit">提交</button>
</form>
<script>
  // 'use strict'
  // 策略模式之表单验证
  // 实现专门用于验证的方法
  const test = {
    isNoEmpty(value, errMsg) { // 空
      if (value === '') return errMsg
    },
    isMobile(value, errMsg) { // 手机 
      if (!/^1[3|5|8][0-9]{9}$/g.test(value)) return errMsg
    },
    minLength(value, errMsg, length) { // 最小长度
      if (value.length < length) return errMsg
    }
  }
  // 实现一个验证类的函数,用于生成验证规则和验证
  const validateFunc = function (form) {
    // 实例化一个验证规则类
    const validator = new Validator()
    // 添加规则
    validator.add(form.username, [{
      rule: 'isNoEmpty',
      msg: '请输入用户名'
    }, {
      rule: 'minLength:6',
      msg: '用户名不得小于6位'
    }])
    validator.add(form.password, [{
      rule: 'minLength:6',
      msg: '密码不得小于6位'
    }])
    validator.add(form.phone, [{
      rule: 'isMobile',
      msg: '手机号无效'
    }])
    return validator.start() // 验证表单
  }

  // 实现验证规则Validator类
  function Validator() {
    this.rules = [] // 用于保存规则列表
  }
  // 添加规则
  /*
    *@args1 form字段标签
    *@args2 '调用的验证规则' 多个参数用','隔开,eg:'minLength:5,8'
    *@args3 '验证失败提示信息'
    */
  Validator.prototype.add = function (field, rules) {
    for (const ruleN of rules) {
      const args = ruleN.rule.split(':')
      // 压入具体验证方法
      this.rules.push(function () {
        // 具体用到的验证方法
        const ruleMethod = args.shift()
        let funcArgs = args.shift()
        // 拼接余参数
        if (funcArgs) {
          funcArgs = funcArgs.split(',')
          args.push(...funcArgs)
        }
        // 验证方法的参数1、2
        args.unshift(field.value, ruleN.msg)
        // 返回执行验证方法的结果
        return test[ruleMethod].apply(field, args)
      })
    }
  }
  // 表单验证
  Validator.prototype.start = function () {
    for (const ruleFunc of this.rules) {
      const msg = ruleFunc()
      if (msg) return msg
    }
  }
  // 表单事件
  const form = document.querySelector('#registerForm')
  form.onsubmit = function () {
    const msg = validateFunc(form)
    if (msg) {
      alert(msg)
      return false
    }
    alert('验证通过')
  }
</script>
```

个人理解

- 算法实现与应用分离，基于应用来选择算法，并非写死绑定
- 基于应用参数来自动选择对应实现，简单说具体实现的策略是由输入决定
- 策略类往往被函数所代替，这时策略模式就成为一种“隐形”的模式

## 代理模式

- 代理模式是为一个对象提供一个代用品或占位符，以便控制对它的访问
- 代理对象帮助本体对象过滤掉一些请求，这种代理叫作保护代理
- 一个开销大的请求，会在代理对象处理，代理对象会判断本体对象什么时候适合接受这个请求，就把请求给本体，这样效率就高了，这是代理模式的另一种形式，叫作虚拟代理
- 保护代理用于控制不同权限的对象对目标对象的访问，而虚拟代理是最常用的一种代理模式

代理模式之图片懒加载，分开写是为了遵循单一职责

```图片懒加载
// img标签
const loadImg = (function () {
  // 添加img标签到body，等需要加载src的时候调用方法设置src
  const img = document.createElement('img')
  document.body.appendChild(img)
  return {
    setSrc(src) { // 此方法为设置真正显示的图片
      img.src = src
    }
  }
})()
// 代理加载
const proxyLoadImg = (function () {
  // 实例化一个占位图片实例
  const img = new Image()
  // 加载完成时显示传入路径的图片
  img.onload = function () {
    // 这里的this指向img，刚开始的时候img.src为undefined
    // 不过由于是异步触发的事件，img.src = src都会先于这个事件触发
    // 所以this.src不会为空，除非不传入src
    loadImg.setSrc(this.src)
  }
  return {
    setSrc(src) {
      loadImg.setSrc('1.png') // 这是还未加载时候的占位图片
      img.src = src // 这里是加载完成后设置的图片路径
    }
  }
})()
proxyLoadImg.setSrc('2.png') // 设置加载完成后的图片
```

- 代理与本体对外接口应该保持一致，即代理的方法属性与本体一致，这样代理和本体可以互换，当哪天不需要代理就可以直接删除，本体上的接口与代理一样，直接兼容
- 如果代理对象和本体对象都为一个函数（函数也是对象），函数必然都能被执行，则可以认为它们也具有一致的“接口”

```定时发送文件列表
// 单次向服务器发送
const sendFile = function (id) {
  console.log('发送文件名：' + id)
}
// 代理发送
const proxySendFiles = (function () {
  // 存储发送id列表
  let ids = [],
    timer
  return function (id) {
    // 加入id列表
    ids.push(id)
    // 定时发送时间未到
    if (timer) return
    // 生成定时器
    timer = setTimeout(() => {
      // 2s向服务器发送一次文件列表ids
      sendFile(ids.join(','))
      clearTimeout(timer)
      // 清空定时器id，否则下次进不来
      timer = null
      // 清空列表ids
      ids.length = 0
    }, 2000)
  }
})()
// 点击一次进入一次代理发送
const btn = document.querySelector('button')
btn.onclick = function () {
  proxySendFiles(~~(Math.random() * 100))
}
```

缓存代理，通过代理实现判断缓存读取操作，挺实用，异步数据用回调

```缓存代理
const compute = function () {
  let sum = 1
  for (let i = 0; i < arguments.length; i++) {
    sum *= arguments[i]
  }
  return sum
}
const proxyCompute = (function () {
  const cache = {}
  return function () {
    const args = Array.from(arguments).join(',')
    for (const [key, value] of Object.entries(cache)) {
      if (key === args) {
        console.log('从缓存读取')
        return value
      }
    }
    cache[args] = compute(...arguments)
  }
})()
proxyCompute(1, 2, 3, 4)
proxyCompute(1, 2, 3, 6)
proxyCompute(1, 2, 3, 4) // 缓存读取
proxyCompute(1, 2, 3, 5)
proxyCompute(1, 2, 3, 6) // 缓存读取
```

缓存代理工厂，通过代理实现对不同函数的代理

```缓存代理工厂
// 缓存代理工厂函数
const compute1 = function () {
  let sum = 1
  for (let i = 0; i < arguments.length; i++) {
    sum *= arguments[i]
  }
  return sum
}
const compute2 = function () {
  let sum = 1
  for (let i = 0; i < arguments.length; i++) {
    sum += arguments[i]
  }
  return sum
}
const proxyComputeMethod = function (fn) {
  const cache = {}
  return function () {
    const args = Array.from(arguments).join()
    for (const [key, value] of Object.entries(cache)) {
      if (key === args) {
        console.log('读取缓存')
        return value
      }
    }
    cache[args] = fn(...arguments)
  }
}
const Mult = proxyComputeMethod(compute1)
Mult(2, 3, 5, 6)
Mult(2, 3, 5, 5)
Mult(2, 3, 5, 6) // 从缓存读取
Mult(2, 3, 5, 5) // 从缓存读取

const Plus = proxyComputeMethod(compute2)
Plus(2, 3, 5, 6)
Plus(2, 3, 5, 5)
Plus(2, 3, 5, 6) // 从缓存读取
Plus(2, 3, 5, 5) // 从缓存读取
```

个人理解

- 代理模式，可以通过代理对象/函数对外暴露本体接口，对本体的操作会先经过代理对象，通过代理对象对来访者进行处理之后在对本体操作
- 可以把代理对象当作一个保护公主的骑士，不让外人随便接触，都需要通过检验筛选最后才对本体操作

## 迭代器模式

- 迭代器模式是指提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示
- 内部迭代器：内部实现迭代元素，比如array的map，forEach等
- 外部迭代器，通过手动控制每次迭代，比较灵活，可以根据实际情况进行迭代操作，比如js中的迭代器对象，就可以通过next()进行一次迭代，比如generator生成器，每次调用生成器都会返回一个迭代对象，通过next()进行迭代操作

简单实现filter的内部迭代器

```filter
// 内部迭代器
const filter = function (arr, fn, thisArg = arr) {
  const result = []
  for (let i = 0; i < arr.length; i++) {
    const res = fn.call(thisArg, arr[i], i, arr)
    if (res) result.push(arr[i])
  }
  return result
}
const array = [5, 6, 8, 7, 9, 2]
const res = filter(array, (val) => {
  if (val > 5) return true
})
console.log(res) // [6,8,7,9]
```

外部迭代器

```外部迭代器
// 构造迭代器函数
const Iterator = function (obj) {
  const keys = Reflect.ownKeys(obj)
  const length = keys.length
  let current = 0
  // 一次迭代操作
  const next = function () {
    // 每次下移一个
    return obj[keys[current++]]
  }
  // 判断是否迭代完成
  const isDone = function () {
    if (current === length) return true
  }
  const getCurrent = function () {
    return obj[current]
  }
  return {
    next,
    isDone,
    getCurrent
  }
}
const obj = {
  name: 'jerry',
  age: 3
}
const iter1 = Iterator(obj)

console.log(iter1.next()) // jerry
console.log(iter1.next()) // 3
```

生成迭代器对象

```迭代器对象
// 实现对象的迭代
const createIterable = function (obj) {
  if (obj.hasOwnProperty(Symbol.iterator)) return obj[Symbol.iterator]
  obj[Symbol.iterator] = function () {
    const keys = Reflect.ownKeys(obj)
    const length = keys.length
    let current = 0
    return {
      [Symbol.iterator]() {
        return this
      },
      next() {
        return {
          value: keys[current],
          done: length === ++current
        }
      },
      value() {
        return keys[current]
      },
      isDone() {
        return length === current
      },
      current
    }
  }
  return obj
}

const obj = {
  name: 'tom',
  age: 5,
  like: 5
}
// 使对象可迭代
createIterable(obj)
// 对象本身无法迭代
for (const i of obj) {
  console.log(i)
}
// 手动迭代
// 生成迭代器
const iter = obj[Symbol.iterator]()
while (!iter.isDone()) {
  console.log(iter.value())
  console.log(iter.next())
}
```

迭代模式应用

```迭代模式应用
const func1 = function (arg) {
  if (typeof arg == 'string') {
    console.log('处理字符串 ' + arg)
    return true
  }
  return false
}
const func2 = function (arg) {
  if (typeof arg == 'number') {
    console.log('处理数字 ' + arg)
    return true
  }
  return false
}
const func3 = function (arg) {
  if (typeof arg == 'boolean') {
    console.log('处理布尔 ' + arg)
    return true
  }
  return false
}
const isFit = function () {
  const args = Array.from(arguments)
  const arg = args.shift()
  for (const func of args) {
    if (func(arg)) {
      console.log('找到处理程序')
      return true
    }
  }
  return false
}
console.log(isFit(5, func1, func2, func3))
```

个人理解

- 迭代器模式，就是通过迭代器来访问内部属性，不需要关系对象内部情况，只需要通过迭代器就能访问内部属性
- 大多数对象都具有内置迭代器，也可自定义迭代器，使其可被for..of迭代
- 迭代器的作用就是方便我们访问对象元素，不需要了解其内部构造，迭代器还可以控制其访问顺序

## 发布-订阅模式/观察者模式

- 发布—订阅模式又叫观察者模式，它定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知
- 此模式就好比，一个主播，有很多关注的人，当主播发送开播通知的时候，每个关注的人都会收到通知
- 